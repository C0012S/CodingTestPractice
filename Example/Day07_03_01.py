"""
다익스트라 알고리즘 : 개선된 구현 방법
  - 단계마다 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택하기 위해 힙(Heap) 자료구조를 이용합니다.
  - 다익스트라 알고리즘이 동작하는 기본 원리는 동일합니다.
    - 현재 가장 가까운 노드를 저장해 놓기 위해서 힙 자료구조를 추가적으로 이용한다는 점이 다릅니다.
    - 현재의 최단 거리가 가장 짧은 노드를 선택해야 하므로 최소 힙을 사용합니다.


다익스트라 알고리즘 : 동작 과정 살펴보기 (우선순위 큐)
  - [초기 상태] 그래프를 준비하고 출발 노드를 설정하여 우선순위 큐에 삽입합니다.
    * 이때 출발 노드는 1 번이라고 가정한다.
    * 이때 Python 등에서 큐에 데이터를 넣을 때, 튜플 형태로 데이터를 묶는 과정에서 첫 번째 원소를 거리로 설정하게 되면 이 거리를 기준으로 해서 더 거리가 작은 원소가 먼저 나올 수 있도록 큐가 구성된다. 물론 이때 우선순위 큐를 최소 힙으로 구현할 때 이와 같이 동작한다고 보면 된다.
    * 매 단계마다 우선순위 큐에서 원소를 꺼내서 해당 노드까지의 거리를 확인한 뒤, 그 노드를 거쳐가는 각각의 경우까지 모두 고려하면 된다.

  - [Step 1] 우선순위 큐에서 원소를 꺼냅니다. 1번 노드는 아직 방문하지 않았으므로 이를 처리합니다.
    * 현재 꺼낸 원소 : (거리 : 0, 노드 : 1)
    * 이때 노드 1을 아직 방문 처리하지 않았기 때문에 이렇게 큐에서 꺼낸 원소를 확인해서 노드 1에 대해서 방문 처리를 수행할 수 있다.
    * 이러한 과정에서 노드 1까지 도달하기 위한 최단 거리 값이 0이라고 확인할 수 있으며, 이러한 노드 1을 거쳐가는 것을 기준으로 해서 그 인접 노드에 대한 최단 거리 값을 갱신할 수 있다.
      인접 노드    현재 값    거쳐갈 때    갱신 여부  
      2번          무한        0 + 2      True
      3번          무한        0 + 5      True
      4번          무한        0 + 1      True
        * 이렇게 갱신이 일어날 때만 큐에 해당 갱신된 노드에 대한 정보를 담아 주면 된다.
    * 갱신된 정보에 따라서 실제 테이블의 값을 갱신해 주고, 이제 이어서 우선순위 큐까지 데이터를 넣어 줄 수 있도록 한다.
    * 큐에 데이터를 넣어 줄 때는 거리 값이 갱신된 노드에 대한 정보를 기준으로 넣어 줄 수 있도록 한다. 마찬가지로 다음 Step에서는 우선순위 큐에서 데이터를 꺼내 줄 수 있도록 한다. (현재 그림에서는 우선순위가 높은 데이터가 위쪽에 들어갈 수 있도록 그림을 그렸다.)

  - [Step 2] 우선순위 큐에서 원소를 꺼냅니다. 4번 노드는 아직 방문하지 않았으므로 이를 처리합니다.
    * 현재 꺼낸 원소 : (거리 : 1, 노드 : 4)
    * 현재 꺼내진 원소는 이와 같으며, 노드 4까지의 최단 거리 값이 1이라는 정보가 담겨 있는 원소다. 이를 통해서 최단 거리 값이 1이라는 것을 알 수 있었고, 마찬가지로 이를 토대로 노드 4를 거쳐가는 경우에 대해서 확인한다. 
    * 노드 4에서 3으로 가는 비용은 3이고, 노드 4에서 노드 5로 가는 비용은 1이다. 그래서 3 번 노드로 가는 경우에는 현재 노드 4까지 가는 비용인 1에다가 노드 4에서 3으로 가는 비용인 3을 더해서 4가 된다. 결과적으로 이 4가 현재 값이었던 5보다 더 작기 때문에 갱신을 수행할 수 있도록 한다. 마찬가지로 인접한 노드인 5 번에 대해서도 동일한 로직을 수행하여 무한이었던 비용이 2로 줄어드는 것을 확인할 수 있다.
      인접 노드    현재 값    거쳐갈 때    갱신 여부  
      3번            5        1 + 3      True
      5번          무한        1 + 1      True
    * 그래서 이 2 개의 노드에 대해서 마찬가지로 갱신이 다 이루어졌기 때문에 테이블에 반영해 주고, 이어서 우선순위 큐에도 이렇게 두 노드에 대한 정보를 모두 넣어 줄 수 있도록 한다.

  - [Step 3] 우선순위 큐에서 원소를 꺼냅니다. 2번 노드는 아직 방문하지 않았으므로 이를 처리합니다.
    * 현재 꺼낸 원소 : (거리 : 2, 노드 : 2)
    * 우선순위 큐에서 원소를 꺼내서 현재 꺼낸 그 노드를 기준으로 해서 그 노드를 거쳐가는 경우를 확인할 수 있도록 한다.
    * 확인해 보면, 2 번 노드에서 4 번 노드로 연결된 간선의 비용은 2 원이고, 2 번 노드에서 3 번 노드로 연결된 간선의 비용은 3인 걸 확인할 수 있다.
    * 그래서 마찬가지로 2 번 노드까지 도달하기 위한 최소 비용은 2 원이기 때문에 3 번 노드의 경우에는 이 2 번 노드에서 3 번 노드로 이동하는 비용인 3을 더한 값인 5와 현재 값을 비교한다. 그래서 걸쳐갈 때가 더 많은 비용이 소요되기 때문에 갱신을 수행하지 않는다.
    * 4 번 또한 마찬가지로 이미 최단 거리를 찾은 노드이기 때문에 값이 갱신되지 않는 걸 확인할 수 있다.
      인접 노드    현재 값    거쳐갈 때    갱신 여부  
      3번            4        2 + 3      False
      4번            1        2 + 2      False
    * 그래서 이처럼 테이블의 값이 바뀌지 않고, 마찬가지로 우선순위 큐에도 어떤 원소도 들어가지 않는 걸 확인할 수 있다.

  - [Step 4] 우선순위 큐에서 원소를 꺼냅니다. 5번 노드는 아직 방문하지 않았으므로 이를 처리합니다.
    * 현재 꺼낸 원소 : (거리 : 2, 노드 : 5)
    * 이때 노드 5까지의 최소 비용이 2라는 것을 알았기 때문에 마찬가지로 이렇게 노드 5까지 이동한 뒤에 3 번 노드, 그리고 6 번 노드로 가는 비용을 고려해서 테이블을 갱신할 수 있도록 한다.
    * 마찬가지로 3 번 노드까지의 비용은 이렇게 3 원으로 갱신되고 6 번 노드까지의 비용은 4 원으로 갱신된다.
      인접 노드    현재 값    거쳐갈 때    갱신 여부  
      3번            4        2 + 1      True
      6번          무한        2 + 2      True
    * 그래서 결과적으로 테이블에 반영된 이후에 3 번 노드와 6 번 노드의 이 두 인접 노드에 대한 갱신된 거리 값이 큐에도 담길 수 있도록 한다.

  - [Step 5] 우선순위 큐에서 원소를 꺼냅니다. 3번 노드는 아직 방문하지 않았으므로 이를 처리합니다.
    * 현재 꺼낸 원소 : (거리 : 3, 노드 : 3)
    * 이제 이어서 이와 같이 하나의 원소를 더 꺼내서 이번에는 3 번 노드에 대해서 처리한다.
    * 3 번 노드에서 2 번 노드로 가는 비용은 3이고, 3 번 노드에서 6 번 노드로 가는 비용은 5이다.
    * 확인해 보면, 거쳐가는 비용이 더 크기 때문에 이 경우에는 갱신을 수행하지 않는다.
      인접 노드    현재 값    거쳐갈 때    갱신 여부  
      2번            2        3 + 3      False
      6번            4        3 + 5      False
    * 따라서 테이블과 우선순위 큐 모두 갱신되지 않으며 3 번 노드에 대해서도 처리가 완료되고, 이제 이어서 우선순위 큐에서 그 다음 원소를 꺼낸다.

  - [Step 6] 우선순위 큐에서 원소를 꺼냅니다. 3번 노드는 이미 방문했으므로 무시합니다.
    * 현재 꺼낸 원소 : (거리 : 4, 노드 : 3)
    * 현재 꺼낸 원소를 확인해 보면 노드 번호가 3 번이다. 다만 이때 3 번 노드는 이미 방문 처리가 된 노드이기 때문에 무시할 수 있도록 한다.
    * 이때 별도로 방문 여부를 기록하는 하나의 테이블을 사용하지 않고, 단순히 최단 거리 테이블과 비교해서 현재 노드 3 번에 대한 그 거리 값보다 크기 때문에 현재 꺼낸 원소를 무시하도록 만드는 방법이 사용될 수 있다.
    * 즉, 현재 이와 같이 3 번 노드에 대해서는 이미 처리가 끝나서 이 3 번 노드까지의 최단 거리 값이 결정된 이후이기 때문에 이처럼 현재 우선순위 큐에서 꺼낸 원소의 값이 테이블에 기록된 값보다 더 크다면 이미 처리가 된 노드라고 간주할 수 있으므로 현재 꺼낸 원소는 그냥 무시하고 다음 Step으로 넘어가면 된다.

  - [Step 7] 우선순위 큐에서 원소를 꺼냅니다. 6번 노드는 아직 방문하지 않았으므로 이를 처리합니다.
    * 현재 꺼낸 원소 : (거리 : 4, 노드 : 6)
    * 이어서 우선순위 큐에서 데이터를 꺼내면, 노드 6에 대한 원소가 나온다. 마찬가지로 노드 6 번에서 이동할 수 있는 인접 노드를 확인한 뒤, 테이블을 갱신하면 된다.
      인접 노드    현재 값    거쳐갈 때    갱신 여부  
            이동할 수 있는 인접 노드가 없습니다.
    * 다만 6 번 노드에서 출발하는 간선이 존재하지 않기 때문에 이동할 수 있는 인접 노드가 없고, 그렇기 때문에 테이블 또한 갱신되지 않고 우선순위 큐 또한 변동이 없다.

  - [Step 8] 우선순위 큐에서 원소를 꺼냅니다. 3번 노드는 이미 방문했으므로 무시합니다.
    * 현재 꺼낸 원소 : (거리 : 5, 노드 : 3)
    * 마지막으로 남아있는 원소까지 꺼내 주게 되면, 이와 같이 3 번 노드가 나온 걸 확인할 수 있다. 이때 3 번 노드는 이미 방문했으므로 마찬가지로 무시하면 된다. 
    * 마찬가지로 이렇게 꺼낸 원소의 거리 값이 현재의 테이블에 기록되어 있는 그 거리 값보다 더 크다면 이미 방문 처리가 된 노드라고 간주할 수 있으므로 현재 Step에 대해서는 무시하면 된다.
      노드 번호    1    2    3    4    5    6
      거리        0    2    3    1    2    4
"""


# 다익스트라 알고리즘 : 개선된 구현 방법 (Python)

import heapq
import sys
input = sys.stdin.readline
INF = int(1e9) # 무한을 의미하는 값으로 10억을 설정

# 노드의 개수, 간선의 개수를 입력받기
n, m = map(int, input().split())
# 시작 노드 번호를 입력받기
start = int(input())
# 각 노드에 연결되어 있는 노드에 대한 정보를 담는 리스트를 만들기
graph = [[] for i in range(n + 1)]
# 최단 거리 테이블을 모두 무한으로 초기화
distance = [INF] * (n + 1)

# 모든 간선 정보를 입력받기
for _ in range(m):
  a, b, c = map(int, input().split())
  # a번 노드에서 b번 노드로 가는 비용이 c라는 의미
  graph[a].append((b, c))

def dijkstra(start):
  q = []
  # 시작 노드로 가기 위한 최단 경로는 0으로 설정하여, 큐에 삽입  #여기에서 큐는 우선순위 큐가 되어야 한다.
  heapq.heappush(q, (0, start)) #힙을 이용해서 삽입과 삭제에 있어서 logN의 복잡도가 보장될 수 있도록 만드는 것이 일반적이다.
  distance[start] = 0
  while q: # 큐가 비어있지 않다면
    # 가장 최단 거리가 짧은 노드에 대한 정보 꺼내기
    dist, now = heapq.heappush(q) #이때 우선순위 큐에는 기본적으로 가장 최단 거리가 짧은 노드에 대한 정보가 먼저 꺼내질 수 있도록 구현되어 있기 때문에 이렇게 데이터를 꺼냈을 때, 그 거리 값과 현재 꺼낸 노드에 대한 정보가 나오는 걸 확인할 수 있다.
    # 현재 노드가 이미 처리된 적이 있는 노드라면 무시
    if distance[now] < dist: #별도의 방문 처리를 위한 테이블이 사용되지 않고, 현재 꺼낸 그 원소의 거리 값이 테이블에 기록되어 있는 값보다 더 크다면 이미 처리가 된 것으로 간주할 수 있기 때문에, 바로 이와 같이 거리 값을 비교해서 현재 꺼낸 원소의 거리 값이 더 크다면 단순히 무시할 수 있도록 하는 걸 확인할 수 있다.
      continue
    #이후에 현재 우선순위 큐에서 꺼낸 노드를 기준으로 해서 그 노드를 거쳐가는 경우를 확인하면 된다.
    # 현재 노드와 연결된 다른 인접한 노드들을 확인
    for i in graph[now]:
      cost = dist + i[1] #이때 이 두 번째 원소(i[1])는 거리 값을 의미한다. #그래서 현재 확인하고 있는 노드까지의 거리 값(dist)에 그 노드와 인접한 다른 노드의 거리 값(i[1])을 더한 값을 cost에 담을 수 있도록 한다.
      # 현재 노드를 거쳐서, 다른 노드로 이동하는 거리가 더 짧은 경우
      if cost < distance[i[0]]:
        distance[i[0]] = cost #그 작은 비용으로 갱신할 수 있도록 한다.
        heapq.heappush(q, (cost, i[0])) #또한 이렇게 값이 갱신될 때마다 우선순위 큐에 해당 정보가 기록될 수 있도록 하는 걸 확인할 수 있다.

# 다익스트라 알고리즘을 수행
dijkstra(start)

# 모든 노드로 가기 위한 최단 거리를 출력
for i in range(1, n + 1):
  # 도달할 수 없는 경우, 무한(INFINITY)이라고 출력
  if distance[i] == INF:
    print("INFINITY")
  # 도달할 수 있는 경우 거리를 출력
  else:
    print(distance[i])

#앞 부분의 코드는 기존의 코드와 동일하고, 이와 같이 다익스트라 알고리즘의 코드 부분이 바뀐 걸 확인할 수 있다.
#기존에 존재하던 현재 상황에서 가장 최단 거리가 짧은 노드를 선택하는 함수는 더 이상 사용되지 않는 걸 확인할 수 있다.
#또한 방문 처리 목적으로 별도로 visited라는 이름의 테이블이 사용되지 않는 걸 확인할 수 있다.
#실제로 우선순위 큐를 이용해서 성능이 개선된 다익스트라 알고리즘의 코드를 확인해 보면 이와 같다.
